if (! lemonade && typeof(require) === 'function') {
    var lemonade = require('lemonadejs');
}

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.studio = factory();
}(this, (function () {

var studio;
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 533:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * render: ()
 * valid-ranges: []
 * disabled
 * dateToNum UTC
 * navigation with icons Enter key
 */


if (! Modal && "function" === 'function') {
    var Modal = __webpack_require__(211);
}

const Helpers = (function() {
    const component = {};

    component.weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    component.months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

    // Excel like dates
    const excelInitialTime = Date.UTC(1900, 0, 0);
    const excelLeapYearBug = Date.UTC(1900, 1, 29);
    const millisecondsPerDay = 86400000;

    // Transform in two digits
    component.Two = function(value) {
        value = '' + value;
        if (value.length === 1) {
            value = '0' + value;
        }
        return value;
    }

    component.isValidDate = function(d) {
        return d instanceof Date && !isNaN(d.getTime());
    }

    component.toString = function (date, dateOnly) {
        let y = null;
        let m = null;
        let d = null;
        let h = null;
        let i = null;
        let s = null;

        if (Array.isArray(date)) {
            y = date[0];
            m = date[1];
            d = date[2];
            h = date[3];
            i = date[4];
            s = date[5];
        } else {
            if (! date) {
                date = new Date();
            }
            y = date.getFullYear();
            m = date.getMonth() + 1;
            d = date.getDate();
            h = date.getHours();
            i = date.getMinutes();
            s = date.getSeconds();
        }

        if (dateOnly === true) {
            return component.Two(y) + '-' + component.Two(m) + '-' + component.Two(d);
        } else {
            return component.Two(y) + '-' + component.Two(m) + '-' + component.Two(d) + ' ' + component.Two(h) + ':' + component.Two(i) + ':' + component.Two(s);
        }
    }

    component.toArray = function (value) {
        let date = value.split(((value.indexOf('T') !== -1) ? 'T' : ' '));
        let time = date[1];

        date = date[0].split('-');
        let y = parseInt(date[0]);
        let m = parseInt(date[1]);
        let d = parseInt(date[2]);
        let h = 0;
        let i = 0;

        if (time) {
            time = time.split(':');
            h = parseInt(time[0]);
            i = parseInt(time[1]);
        }
        return [y, m, d, h, i, 0];
    }

    component.arrayToStringDate = function(arr) {
        return component.toString(arr, true);
    }

    component.dateToNum = function(jsDate) {
        if (typeof(jsDate) === 'string') {
            jsDate = new Date(jsDate + '  GMT+0');
        }
        let jsDateInMilliseconds = jsDate.getTime();
        if (jsDateInMilliseconds >= excelLeapYearBug) {
            jsDateInMilliseconds += millisecondsPerDay;
        }
        jsDateInMilliseconds -= excelInitialTime;

        return jsDateInMilliseconds / millisecondsPerDay;
    }

    component.numToDate = function(excelSerialNumber, asString){
        if (! excelSerialNumber) {
            return '';
        }

        let jsDateInMilliseconds = excelInitialTime + excelSerialNumber * millisecondsPerDay;
        if (jsDateInMilliseconds >= excelLeapYearBug) {
            jsDateInMilliseconds -= millisecondsPerDay;
        }

        const d = new Date(jsDateInMilliseconds);

        let arr = [
            d.getUTCFullYear(),
            component.Two(d.getUTCMonth() + 1),
            component.Two(d.getUTCDate()),
            component.Two(d.getUTCHours()),
            component.Two(d.getUTCMinutes()),
            component.Two(d.getUTCSeconds()),
        ];

        if (asString) {
            return component.arrayToStringDate(arr);
        } else {
            return arr;
        }
    }

    return component;
})();

; (function (global, factory) {
     true ? module.exports = factory() :
    0;
}(this, (function () {

    const isNumber = function (num) {
        if (typeof(num) === 'string') {
            num = num.trim();
        }
        return !isNaN(num) && num !== null && num !== '';
    }

    /**
     * Create a data calendar object based on the view
     */
    const views = {
        years: function(date) {
            let year = date.getFullYear();
            let result = [];
            let start = year % 16;
            let complement = 16 - start;

            for (let i = year-start; i < year+complement; i++) {
                let item = {
                    title: i,
                    value: i
                };
                result.push(item);
                // Select cursor
                if (this.cursor.y === i) {
                    // Select item
                    item.selected = true;
                    // Cursor
                    this.cursor.index = result.length - 1;
                }
            }
            return result;
        },
        months: function(date) {
            let year = date.getFullYear();
            let result = [];
            for (let i = 0; i < 12; i++) {
                let item = {
                    title: Helpers.months[i].substring(0,3),
                    value: i
                }
                // Add the item to the data
                result.push(item);
                // Select cursor
                if (this.cursor.y === year && this.cursor.m === i) {
                    // Select item
                    item.selected = true;
                    // Cursor
                    this.cursor.index = result.length - 1;
                }
            }

            return result;
        },
        days: function(date) {
            let year = date.getFullYear();
            let month = date.getMonth();
            let data = filterData.call(this, year, month);

            // First day
            let tmp = new Date(year, month, 1, 0, 0, 0);
            let firstDay = tmp.getDay();

            let result = [];
            for (let i = 1-firstDay; i <= 42-firstDay; i++) {
                // Get the day
                tmp = new Date(year, month, i, 0, 0, 0);
                // Day
                let day = tmp.getDate();
                // Create the item
                let item = {
                    title: day,
                    value: i,
                    number: Helpers.dateToNum(tmp.toString())
                }
                // Add the item to the date
                result.push(item);
                // Check selections
                if (tmp.getMonth() !== month) {
                    // Days are not in the current month
                    item.grey = true;
                } else {
                    // Check for data
                    let d = [ year, Helpers.Two(month+1), Helpers.Two(day)].join('-');
                    if (data && data[d]) {
                        item.data = data[d];
                    }
                }
                // Month
                let m = tmp.getMonth();
                // Select cursor
                if (this.cursor.y === year && this.cursor.m === m && this.cursor.d === day) {
                    // Select item
                    item.selected = true;
                    // Cursor
                    this.cursor.index = result.length - 1;
                }
                // Select range
                if (this.range && this.rangeValues) {
                    // Mark the start and end points
                    if (this.rangeValues[0] === item.number) {
                        item.range = true;
                        item.start = true;
                    }
                    if (this.rangeValues[1] === item.number) {
                        item.range = true;
                        item.end = true;
                    }
                    // Re-recreate teh range
                    if (this.rangeValues[0] && this.rangeValues[1]) {
                        if (this.rangeValues[0] <= item.number && this.rangeValues[1] >= item.number) {
                            item.range = true;
                        }
                    }
                }
            }

            return result;
        },
        hours: function() {
            let result = [];
            for (let i = 0; i < 24; i++) {
                let item = {
                    title: Helpers.Two(i),
                    value: i
                };
                result.push(item);
            }
            return result;
        },
        minutes: function() {
            let result = [];
            for (let i = 0; i < 60; i=i+5) {
                let item = {
                    title: Helpers.Two(i),
                    value: i
                };
                result.push(item);
            }
            return result;
        }
    }

    const filterData = function(year, month) {
        // Data for the month
        let data = {};
        if (Array.isArray(this.data)) {
            this.data.map(function (v) {
                let d = year + '-' + Helpers.Two(month + 1);
                if (v.date.substring(0, 7) === d) {
                    if (!data[v.date]) {
                        data[v.date] = [];
                    }
                    data[v.date].push(v);
                }
            });
        }
        return data;
    }

    // Get the short weekdays name
    const getWeekdays = function() {
        return Helpers.weekdays.map(w => {
            return { title: w.substring(0, 1) };
        })
    }

    // Define the hump based on the view
    const getJump = function(e) {
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            return this.view === 'days' ? 7 : 4;
        }

        return 1;
    }

    // Get the position of the data based on the view
    const getPosition = function() {
        let position = 2;
        if (this.view === 'years') {
            position = 0;
        } else if (this.view === 'months') {
            position = 1;
        }
        return position;
    }


    const Calendar = function() {
        let self = this;

        const onchange = self.onchange;

        // Weekdays
        self.weekdays = getWeekdays();

        // Cursor
        self.cursor = {};

        // Calendar date
        let date = new Date();

        // Range
        self.rangeValues = null;

        /**
         * Update the internal date
         * @param {Date|string|number[]} d instance of Date
         *
         */
        const setDate = function(d) {
            if (Array.isArray(d)) {
                d = new Date(Date.UTC(...d));
            } else if (typeof(d) === 'string') {
                d = new Date(d);
            }
            // Update internal date
            date = d;
            // Update the headers of the calendar
            let value = d.toISOString().substring(0,10).split('-');
            // Update the month label
            self.month = Helpers.months[parseInt(value[1])-1];
            // Update the year label
            self.year = parseInt(value[0]);
            // Load data
            if (! self.view) {
                // Start on the days view will start the data
                self.view = 'days';
            } else {
                // Reload the data for the same view
                self.options = views[self.view].call(self, date);
            }
        }

        const getDate = function() {
            let v = [ self.cursor.y, self.cursor.m, self.cursor.d ];
            let d = new Date(Date.UTC(...v));
            // Update the headers of the calendar
            return d.toISOString().substring(0, 10);
        }

        /**
         * Set the internal cursor
         * @param {object} s
         */
        const setCursor = function(s) {
            // Remove selection from the current object
            let item = self.options[self.cursor.index];
            if (typeof(item) !== 'undefined') {
                item.selected = false;
            }
            // Update the date based on the click
            let v = updateDate(s.value, getPosition.call(self));
            let d = new Date(Date.UTC(...v));
            // Update cursor controller
            self.cursor = {
                y: d.getFullYear(),
                m: d.getMonth(),
                d: d.getDate(),
            };
            // Update cursor based on the object position
            if (s) {
                // Update selected property
                s.selected = true;
                // New cursor
                self.cursor.index = self.options.indexOf(s);
            }

            if (typeof (self.onupdate) === 'function') {
                self.onupdate(self, renderValue());
            }

            return d;
        }

        /**
         * Update the current date
         * @param {number} v new value for year, month or day
         * @param {number} position (0,1,2 - year,month,day)
         * @returns {number[]}
         */
        const updateDate = function(v, position) {
            // Current internal date
            let value = [date.getFullYear(), date.getMonth(), date.getDate(),0,0,0];
            // Update internal date
            value[position] = v;
            // Return new value
            return value;
        }

        /**
         * This method move the data from the view up or down
         * @param direction
         */
        const move = function(direction) {
            let value;

            // Update the new internal date
            if (self.view === 'days') {
                // Select the new internal date
                value = updateDate(date.getMonth()+direction, 1);
            } else if (self.view === 'months') {
                // Select the new internal date
                value = updateDate(date.getFullYear()+direction, 0);
            } else if (self.view === 'years') {
                // Select the new internal date
                value = updateDate(date.getFullYear()+(direction*16), 0);
            }

            // Update view
            if (value) {
                setDate(value);
            }
        }

        /**
         * Keyboard handler
         * @param {number} direction of the action
         * @param {object} e keyboard event
         */
        const moveCursor = function(direction, e) {
            direction = direction * getJump.call(self, e);
            // Remove the selected from the current selection
            let s = self.options[self.cursor.index];
            // If the selection is going outside the viewport
            if (typeof(s) === 'undefined' || ! s.selected) {
                // Go back to the view
                setDate([ self.cursor.y, self.cursor.m, self.cursor.d ]);
            }

            // Jump to the index
            let index = self.cursor.index + direction;

            // See if the new position is in the viewport
            if (typeof(self.options[index]) === 'undefined') {
                // Adjust the index for next collection of data
                if (self.view === 'days') {
                    if (index < 0) {
                        index = 42 + index;
                    } else {
                        index = index - 42;
                    }
                } else if (self.view === 'years') {
                    if (index < 0) {
                        index = 4 + index;
                    } else {
                        index = index - 4;
                    }
                } else if (self.view === 'months') {
                    if (index < 0) {
                        index = 12 + index;
                    } else {
                        index = index - 12;
                    }
                }

                // Move the data up or down
                move(direction > 0 ? 1 : -1);
            }

            // Update the date based on the click
            setCursor(self.options[index]);

            // Update ranges
            updateRange(self.options[index])
        }

        /**
         * Handler blur
         * @param e
         */
        const blur = function(e) {
            if (self.modal) {
                if (!(e.relatedTarget && self.modal.el.contains(e.relatedTarget))) {
                    if (self.modal.closed === false) {
                        self.modal.closed = true
                    }
                }
            }
        }

        /**
         * Set the limits of a range
         * @param s
         */
        const setRange = function(s) {
            if (self.view === 'days' && self.range) {
                let d = getDate();
                // Date to number
                let number = Helpers.dateToNum(d);
                // Start a new range
                if (self.rangeValues && (self.rangeValues[0] >= number || self.rangeValues[1])) {
                    destroyRange();
                }
                // Range
                s.range = true;
                // Update range
                if (! self.rangeValues) {
                    s.start = true;
                    self.rangeValues = [number, null];
                } else {
                    s.end = true;
                    self.rangeValues[1] = number;
                }
            }
        }

        /**
         * Update the visible range
         * @param s
         */
        const updateRange = function(s) {
            if (self.range && self.view === 'days' && self.rangeValues) {
                // Creating a range
                if (self.rangeValues[0] && ! self.rangeValues[1]) {
                    let number = s.number;
                    if (number) {
                        // Update range properties
                        for (let i = 0; i < self.options.length; i++) {
                            // Item number
                            let v = self.options[i].number;
                            // Update property condition
                            self.options[i].range = v >= self.rangeValues[0] && v <= number;
                        }
                    }
                }
            }
        }

        /**
         * Destroy the range
         */
        const destroyRange = function() {
            for (let i = 0; i < self.options.length; i++) {
                self.options[i].range = false;
                self.options[i].start = false;
                self.options[i].end = false;
            }
            self.rangeValues = null;
        }

        const renderValue = function() {
            let value = null;
            if (self.range) {
                if (Array.isArray(self.rangeValues)) {
                    if (self.numeric) {
                        value = self.rangeValues;
                    } else {
                        value = [
                            Helpers.numToDate(self.rangeValues[0], true),
                            Helpers.numToDate(self.rangeValues[1], true)
                        ];
                    }
                }
            } else {
                value = getDate();
                if (self.numeric) {
                    value = Helpers.dateToNum(value);
                }
            }
            return value;
        }

        const updateValue = function(v) {
            if (self.range) {
                if (v) {
                    if (! Array.isArray(v)) {
                        v = v.split(',');
                    }
                    self.rangeValues = [...v];

                    if (v[0] && typeof(v[0]) === 'string' && v[0].indexOf('-')) {
                        self.rangeValues[0] = Helpers.dateToNum(v[0]);
                    }
                    if (v[1] && typeof(v[1]) === 'string' && v[1].indexOf('-')) {
                        self.rangeValues[1] = Helpers.dateToNum(v[1]);
                    }

                    v = v[0];
                }
            }

            let d;
            if (v) {
                v = isNumber(v) ? Helpers.numToDate(v, true) : v;
                d = new Date(v);
            }
            // if no date is defined
            if (! Helpers.isValidDate(d)) {
                d = new Date();
            }
            // Update my index
            self.cursor = {
                y: d.getFullYear(),
                m: d.getMonth(),
                d: d.getDate(),
            };
            // Update the internal calendar date
            setDate(d);
        }

        let autoInput = null;

        const getInput = function() {
            let input = self.input;
            if (input && input.current) {
                input = input.current;
            } else {
                if (input === 'auto') {
                    if (! autoInput) {
                        autoInput = document.createElement('input');
                        autoInput.type = 'text';
                        if (self.class) {
                            autoInput.class = self.class;
                        }
                        if (self.name) {
                            autoInput.name = self.name;
                        }
                        if (self.placeholder) {
                            autoInput.placeholder = self.placeholder;
                        }
                        self.el.parentNode.insertBefore(autoInput, self.el);
                    }
                    input = autoInput;
                }
            }
            return input;
        }

        /**
         * Select an item with the enter or mouse
         * @param {object} e - mouse event
         * @param {object} item - selected cell
         */
        self.select = function(e, item) {
            // Update cursor generic
            let value = setCursor(item);
            // Based where was the click
            if (self.view !== 'days') {
                // Update the internal date
                setDate(value);
                // Back to the days
                self.view = 'days';
            } else {
                if (! self.range) {
                    self.update();
                }
            }
        }

        self.selectRange = function(e, item) {
            if (self.view === 'days' && self.range === true) {
                // Update cursor generic
                setCursor(item);
                // Update range
                setRange(item);
            }
        }

        /**
         * Next handler
         * @param {object?} e mouse event
         */
        self.next = function(e) {
            if (! e || e.type === 'click') {
                // Icon click
                move(1);
            } else {
                // Keyboard handler
                moveCursor(1, e);
            }
        }

        /**
         * Next handler
         * @param {object?} e mouse event
         */
        self.prev = function(e) {
            if (! e || e.type === 'click') {
                // Icon click
                move(-1);
            } else {
                // Keyboard handler
                moveCursor(-1, e);
            }
        }

        /**
         * Open the modal
         */
        self.open = function(e) {
            if (self.modal && self.modal.closed) {
                let input = getInput();
                // Open modal
                self.modal.closed = false;
                // Set the focus on the content to use the keyboard
                if (! (input && e.target.getAttribute('readonly') === null)) {
                    self.content.focus();
                }
                // Populate components
                self.hours = views.hours();
                self.minutes = views.minutes();
                // Update the internal date values
                updateValue(self.value);
            }
        }

        /**
         * Close the modal
         */
        self.close = function() {
            if (self.modal && self.modal.closed === false) {
                // Close modal
                self.modal.closed = true;
                // Cancel range events
                destroyRange();
            }
        }

        self.reset = function() {
            self.setValue('');
            self.close();
        }

        self.update = function() {
            self.setValue(renderValue());
            self.close();
        }

        /**
         * Change the view
         */
        self.setView = function() {
            let v = this.getAttribute('data-view');
            if (v) {
                self.view = v;
            }
        }

        /**
         * Get value from cursor
         * @returns {string}
         */
        self.getValue = function() {
            return self.value;
        }

        self.setValue = function(v) {
            // Update the internal controllers
            updateValue(v);
            // Destroy range
            destroyRange();
            // Update input
            if (self.input) {
                let input = getInput();
                input.value = v;
            }

            if (v !== self.value) {
                // Update value
                self.value = v;
            }
        }

        self.onchange = function(prop) {
            if (prop === 'view') {
                if (typeof(views[self.view]) === 'function') {
                    // When change the view update the data
                    self.options = views[self.view].call(self, date);
                }
            } else if (prop === 'value') {
                if (typeof (onchange) === 'function') {
                    onchange(self, self.value);
                }
                if (typeof (self.onupdate) === 'function') {
                    self.onupdate(self, self.value);
                }
                if (typeof(self.onChange) === 'function') {
                   let input = getInput();
                   if (input) {
                       input.dispatchEvent(new Event('change', {bubbles: true, cancelable: true}));
                   }
                }

                self.setValue(self.value);
            } else if (prop === 'options') {
                self.content.focus();
            }
        }

        self.onload = function() {
            // Populate components
            self.hours = views.hours();
            self.minutes = views.minutes();

            if (self.type !== "inline") {
                // Create modal instance
                self.modal = {
                    width: 300,
                    closed: true,
                    focus: false,
                    position: 'absolute',
                    'auto-close': false,
                    'auto-adjust': true,
                };
                // Generate modal
                Modal(self.el, self.modal);
            }

            // Create input controls
            if (self.input) {
                let input = getInput();
                input.classList.add('lm-calendar-input');
                input.addEventListener('focus', self.open);
                input.addEventListener('click', self.open);
                input.addEventListener('blur', blur);

                if (self.onChange) {
                    input.addEventListener('change', self.onChange);
                }

                // Retrieve the value
                if (self.value) {
                    input.value = self.value;
                } else if (input.value && input.value !== self.value) {
                    self.value = input.value;
                }
            }

            // Update the internal date values
            updateValue(self.value);

            /**
             * Handler keyboard
             * @param {object} e - event
             */
            self.content.addEventListener('keydown', function(e){
                let prevent = false;
                if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
                    self.prev(e);
                    prevent = true;
                } else if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
                    self.next(e);
                    prevent = true;
                } else if (e.key === 'Enter') {
                    // Current view
                    let view = self.view;
                    // Select
                    self.selectRange(e, self.options[self.cursor.index]);
                    self.select(e, self.options[self.cursor.index]);
                    // If is range do something different
                    if (view === 'days' && ! self.range) {
                        self.update();
                    }
                    prevent = true;
                } else {
                    if (self.input) {
                        jSuites.mask(e);
                    }
                }

                if (prevent) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                }
            });

            /**
             * Mouse wheel handler
             * @param {object} e - mouse event
             */
            self.content.addEventListener('wheel', function(e){
                if (self.wheel !== false) {
                    if (e.deltaY < 0) {
                        self.prev();
                    } else {
                        self.next();
                    }
                    e.preventDefault();
                }
            });

            /**
             * Range handler
             * @param {object} e - mouse event
             */
            self.content.addEventListener('mouseover', function(e){
                let parent = e.target.parentNode
                if (parent === self.content) {
                    let index = Array.prototype.indexOf.call(parent.children, e.target);
                    updateRange(self.options[index]);
                }
            });

            // Create event for focus out
            self.el.addEventListener("focusout", (e) => {
                let input = getInput();
                if (e.relatedTarget !== input && ! self.el.contains(e.relatedTarget)) {
                    self.close();
                }
            });
        }

        return `<div class="lm-calendar" :value="self.value" data-grid="{{self.grid}}">
            <div class="lm-calendar-options">
                <button type="button" onclick="self.reset">Reset</button>
                <button type="button" onclick="self.update">Done</button>
            </div>
            <div class="lm-calendar-container" data-view="{{self.view}}">
                <div class="lm-calendar-header">
                    <div>
                        <div class="lm-calendar-labels"><button type="button" onclick="self.setView" data-view="months">{{self.month}}</button> <button type="button" onclick="self.setView" data-view="years">{{self.year}}</button></div> 
                        <div class="lm-calendar-navigation">
                            <button type="button" class="material-icons lm-ripple" onclick="self.prev" tabindex="0">arrow_drop_up</button>
                            <button type="button" class="material-icons lm-ripple" onclick="self.next" tabindex="0">arrow_drop_down</button>
                        </div>
                    </div>
                    <div class="lm-calendar-weekdays" :loop="self.weekdays"><div>{{self.title}}</div></div>
                </div>
                <div class="lm-calendar-content" :loop="self.options" tabindex="0" :ref="self.content">
                    <div data-start="{{self.start}}" data-end="{{self.end}}" data-range="{{self.range}}" data-event="{{self.data}}" data-grey="{{self.grey}}" data-bold="{{self.bold}}" data-selected="{{self.selected}}" onclick="self.parent.select" onmousedown="self.parent.selectRange">{{self.title}}</div>
                </div>
                <div class="lm-calendar-footer" data-visible="{{self.footer}}">
                    <div class="lm-calendar-time" data-visible="{{self.time}}"><select :loop="self.hours"><option value="{{self.value}}">{{self.title}}</option></select>:<select :loop="self.minutes"><option value="{{self.value}}">{{self.title}}</option></select></div>
                    <div class="lm-calendar-update"><input type="button" value="Update" onclick="self.update" class="lm-ripple"></div>
                </div>
            </div>
        </div>`
    }

    // Register the LemonadeJS Component
    lemonade.setComponents({ Calendar: Calendar });
    // Register the web component
    lemonade.createWebComponent('calendar', Calendar);

    return function (root, options) {
        if (typeof (root) === 'object') {
            lemonade.render(Calendar, root, options)
            return options;
        } else {
            return Calendar.call(this, root)
        }
    }
})));

/***/ }),

/***/ 444:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



if (! Modal && "function" === 'function') {
    var Modal = __webpack_require__(211);
}

if (! Tabs && "function" === 'function') {
    var Tabs = __webpack_require__(128);
}

; (function (global, factory) {
     true ? module.exports = factory() :
    0;
}(this, (function () {

    const defaultPalette =  [
        ["#ffebee", "#fce4ec", "#f3e5f5", "#e8eaf6", "#e3f2fd", "#e0f7fa", "#e0f2f1", "#e8f5e9", "#f1f8e9", "#f9fbe7", "#fffde7", "#fff8e1", "#fff3e0", "#fbe9e7", "#efebe9", "#fafafa", "#eceff1"],
        ["#ffcdd2", "#f8bbd0", "#e1bee7", "#c5cae9", "#bbdefb", "#b2ebf2", "#b2dfdb", "#c8e6c9", "#dcedc8", "#f0f4c3", "#fff9c4", "#ffecb3", "#ffe0b2", "#ffccbc", "#d7ccc8", "#f5f5f5", "#cfd8dc"],
        ["#ef9a9a", "#f48fb1", "#ce93d8", "#9fa8da", "#90caf9", "#80deea", "#80cbc4", "#a5d6a7", "#c5e1a5", "#e6ee9c", "#fff59d", "#ffe082", "#ffcc80", "#ffab91", "#bcaaa4", "#eeeeee", "#b0bec5"],
        ["#e57373", "#f06292", "#ba68c8", "#7986cb", "#64b5f6", "#4dd0e1", "#4db6ac", "#81c784", "#aed581", "#dce775", "#fff176", "#ffd54f", "#ffb74d", "#ff8a65", "#a1887f", "#e0e0e0", "#90a4ae"],
        ["#ef5350", "#ec407a", "#ab47bc", "#5c6bc0", "#42a5f5", "#26c6da", "#26a69a", "#66bb6a", "#9ccc65", "#d4e157", "#ffee58", "#ffca28", "#ffa726", "#ff7043", "#8d6e63", "#bdbdbd", "#78909c"],
        ["#f44336", "#e91e63", "#9c27b0", "#3f51b5", "#2196f3", "#00bcd4", "#009688", "#4caf50", "#8bc34a", "#cddc39", "#ffeb3b", "#ffc107", "#ff9800", "#ff5722", "#795548", "#9e9e9e", "#607d8b"],
        ["#e53935", "#d81b60", "#8e24aa", "#3949ab", "#1e88e5", "#00acc1", "#00897b", "#43a047", "#7cb342", "#c0ca33", "#fdd835", "#ffb300", "#fb8c00", "#f4511e", "#6d4c41", "#757575", "#546e7a"],
        ["#d32f2f", "#c2185b", "#7b1fa2", "#303f9f", "#1976d2", "#0097a7", "#00796b", "#388e3c", "#689f38", "#afb42b", "#fbc02d", "#ffa000", "#f57c00", "#e64a19", "#5d4037", "#616161", "#455a64"],
        ["#c62828", "#ad1457", "#6a1b9a", "#283593", "#1565c0", "#00838f", "#00695c", "#2e7d32", "#558b2f", "#9e9d24", "#f9a825", "#ff8f00", "#ef6c00", "#d84315", "#4e342e", "#424242", "#37474f"],
        ["#b71c1c", "#880e4f", "#4a148c", "#1a237e", "#0d47a1", "#006064", "#004d40", "#1b5e20", "#33691e", "#827717", "#f57f17", "#ff6f00", "#e65100", "#bf360c", "#3e2723", "#212121", "#263238"],
    ]

    const Grid = function() {
        const self = this;

        if (! self.palette) {
            self.palette = defaultPalette;
        }

        self.onchange = function (property) {
            if (property === 'palette') {
                self.constructRows()
            }
        }

        self.select = function (event) {
            if (event.target.tagName === 'TD') {
                let color = event.target.getAttribute('data-value')

                // Remove current selected mark
                let selected = self.el.querySelector('.lm-color-selected');
                if (selected) {
                    selected.classList.remove('lm-color-selected');
                }

                // Mark cell as selected
                if (color) {
                    event.target.classList.add('lm-color-selected');
                    self.parent.parent.set(color);
                }
            }
        }

        self.constructRows = function () {
            let tbody = [];
            for (let j = 0; j < self.palette.length; j++) {
                let row = []
                for (let i = 0; i < self.palette[j].length; i++) {
                    let color = self.palette[j][i];
                    row.push(`<td data-value="${color}" style="background-color: ${color}" />`);
                }
                tbody.push(`<tr>${row.join('')}</tr>`);
            }
            self.table.innerHTML = tbody.join('');
        }

        return `<div class="lm-color-grid" :palette="self.palette">
            <table cellpadding="7" cellspacing="0" onclick="self.select" :ref="self.table" :ready="self.constructRows()"></table>
        </div>`
    }

    const Spectrum = function() {
        let self = this;
        let context = null;

        let decToHex = function(num) {
            let hex = num.toString(16);
            return hex.length === 1 ? "0" + hex : hex;
        }
        let rgbToHex = function(r, g, b) {
            return "#" + decToHex(r) + decToHex(g) + decToHex(b);
        }

        const draw = function() {
            let g = context.createLinearGradient(0, 0, self.canvas.width, 0);
            // Create color gradient
            g.addColorStop(0,    "rgb(255,0,0)");
            g.addColorStop(0.15, "rgb(255,0,255)");
            g.addColorStop(0.33, "rgb(0,0,255)");
            g.addColorStop(0.49, "rgb(0,255,255)");
            g.addColorStop(0.67, "rgb(0,255,0)");
            g.addColorStop(0.84, "rgb(255,255,0)");
            g.addColorStop(1,    "rgb(255,0,0)");
            context.fillStyle = g;
            context.fillRect(0, 0, self.canvas.width, self.canvas.height);
            g = context.createLinearGradient(0, 0, 0, self.canvas.height);
            g.addColorStop(0,   "rgba(255,255,255,1)");
            g.addColorStop(0.5, "rgba(255,255,255,0)");
            g.addColorStop(0.5, "rgba(0,0,0,0)");
            g.addColorStop(1,   "rgba(0,0,0,1)");
            context.fillStyle = g;
            context.fillRect(0, 0, self.canvas.width, self.canvas.height);
        }

        self.onload = function() {
            context = self.canvas.getContext("2d", { willReadFrequently: true });
            draw();
        }

        // Moves the marquee point to the specified position
        self.update = function(e) {
            let x;
            let y;
            let buttons = 1;
            if (e.type === 'touchmove') {
                x = e.changedTouches[0].clientX;
                y = e.changedTouches[0].clientY;
            } else {
                buttons = e.buttons;
                x = e.clientX;
                y = e.clientY;
            }

            if (buttons === 1) {
                let rect = self.el.getBoundingClientRect();
                let left = x - rect.left;
                let top = y - rect.top;
                // Get the color in this pixel
                let pixel = context.getImageData(left, top, 1, 1).data;
                // Position pointer
                self.point.style.left = left + 'px'
                self.point.style.top = top + 'px'

                // Return color
                self.parent.parent.set(rgbToHex(pixel[0], pixel[1], pixel[2]));
            }
        }

        return `<div class="lm-color-hsl">
            <canvas :ref="self.canvas" onmousedown="self.update(e)" onmousemove="self.update(e)" ontouchmove="self.update(e)"></canvas>
            <div class="lm-color-point" :ref="self.point"></div>
        </div>`;
    }

    const Color = function() {
        let self = this;

        let value = null;

        const onchange = self.onchange;

        const getInput = function(create) {
            let input = self.input;
            if (input && input.current) {
                input = input.current;
            } else {
                if (create && input === 'auto') {
                    input = document.createElement('input');
                    input.type = 'text';
                    if (self.class) {
                        input.class = self.class;
                    }
                    if (self.name) {
                        input.name = self.name;
                    }
                    self.el.parentNode.insertBefore(input, self.el);
                    // Auto create input
                    self.input = input;
                }
            }
            return input;
        }

        self.onchange = function(prop) {
            if (prop === 'value') {
                let input = getInput();
                if (input) {
                    input.value = self.value;
                    if (self.value) {
                        input.style.color = self.value;
                        input.style.boxShadow = '-2px 0 0 0';
                    } else {
                        input.style.color = ''
                        input.style.boxShadow = '';
                    }
                }

                if (typeof(onchange) === 'function') {
                    onchange.call(self, self, self.value);
                }
            }
        }

        /**
         * Open the modal
         */
        self.open = function() {
            // Open if modal is closed
            if (self.modal && self.modal.closed === true) {
                // Current value
                value = self.value;
                // Open the modal
                self.modal.closed = false;
                // Table
                let table = self.tabs.grid.table;
                // Remove any selection
                let o = table.querySelector('.lm-color-selected');
                if (o) {
                    o.classList.remove('lm-color-selected');
                }
                // Selected
                o = table.querySelector('[data-value="'+self.value+'"]');
                if (o) {
                    o.classList.add('lm-color-selected');
                }
            }
        }

        /**
         * Close the modal
         */
        self.close = function() {
            if (self.modal && self.modal.closed === false) {
                self.modal.closed = true;
            }
        }

        const applyValue = function(v) {
            if (self.value !== v) {
                self.value = v;
            }
        }

        self.update = function() {
            applyValue(value);
            self.close();
        }

        self.reset = function() {
            applyValue('');
            self.close();
        }

        self.set = function(v) {
            value = v;
            applyValue(value);
        }

        self.get = function() {
            return value;
        }

        /**
         * Handler blur
         * @param e
         */
        self.blur = function(e) {
            if (self.modal) {
                if (! (e.relatedTarget && self.modal.el.contains(e.relatedTarget))) {
                    if (self.modal.closed === false) {
                        self.modal.closed = true
                    }
                }
            }
        }

        self.onload = function() {
            if (self.type !== "inline") {
                // Create modal instance
                self.modal = {
                    width: 260,
                    height: 240,
                    closed: true,
                    onopen: self.onopen,
                    onclose: self.onclose,
                    focus: false,
                    position: 'absolute',
                    'auto-close': false,
                    'auto-adjust': true,
                };
                // Generate modal
                Modal(self.el, self.modal);
            }

            // Create input controls
            let input = getInput(true);
            if (input) {
                input.classList.add('lm-color-input');
                input.addEventListener('focus', self.open);
                input.addEventListener('click', self.open);
                input.addEventListener('blur', self.blur);
                input.addEventListener('change', (e) => {
                    applyValue(input.value);
                });

                // Retrieve the value
                if (self.value) {
                    input.value = self.value;
                } else if (self.input.value) {
                    self.value = input.value;
                }
            }

            // Create event for focus out
            self.el.addEventListener("focusout", (e) => {
                if (e.relatedTarget !== input && ! self.el.contains(e.relatedTarget)) {
                    self.close();
                }
            });
        }

        let template = `<div class="lm-color" :value="self.value">
            <div class="lm-color-options">
                <button type="button" onclick="self.reset">Reset</button>
                <button type="button" onclick="self.update">Done</button>
            </div>
            <Tabs selected="0" position="center" :ref="self.tabs">
                <div title="Grid"><Grid :palette="self.parent.palette" :ref="self.grid" /></div>
                <div title="Spectrum"><Spectrum :ref="self.spectrum"/></div>
            </Tabs>
        </div>`

        return lemonade.element(template, self, { Spectrum, Grid });
    }

    lemonade.setComponents({ Color: Color });

    return function (root, options) {
        if (typeof (root) === 'object') {
            lemonade.render(Color, root, options)
            return options;
        } else {
            return Color.call(this, root)
        }
    }
})));

/***/ }),

/***/ 577:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



if (! Modal && "function" === 'function') {
    var Modal = __webpack_require__(211);
}

; (function (global, factory) {
     true ? module.exports = factory() :
    0;
}(this, (function () {

    // Get the coordinates of the action
    const getCoords = function(e) {
        let x;
        let y;

        if (e.changedTouches && e.changedTouches[0]) {
            x = e.changedTouches[0].clientX;
            y = e.changedTouches[0].clientY;
        } else {
            x = e.clientX;
            y = e.clientY;
        }

        // Adjust for any scrollable parent element
        let b = document.body;
        x -= b.scrollLeft;
        y -= b.scrollTop;

        return [x,y];
    }

    const Item = function() {
        let self = this;

        self.onload = function() {
            if (typeof(self.render) === 'function') {
                self.render.call(self, self.el);
            }
        }

        self.hasSubmenu = !! self.submenu;

        if (self.type === 'line') {
            return `<hr />`;
        } else if (self.type === 'inline') {
            return `<div></div>`;
        } else {
            return `<div class="lm-menu-item" data-disabled="{{self.disabled}}" data-cursor="{{self.cursor}}" data-icon="{{self.icon}}" data-submenu="{{self.hasSubmenu}}" onmouseup="self.parent.parent.mouseUp(self, e)" onmouseenter="self.parent.parent.mouseEnter(self)" onmouseleave="self.parent.parent.mouseLeave(self)">
                <a>{{self.title}}</a> <div>{{self.shortcut}}</div>
            </div>`;
        }
    }

    const Create = function() {
        let self = this;

        // Delay on open
        let delayTimer;
        // Save the position of this modal
        let index = self.parent.modals.length;

        // Close handler
        self.onclose = function() {
            // Reset any cursor
            resetCursor.call(self.modal);
            // Parent
            if (typeof(self.parent.onclose) === 'function') {
                self.parent.onclose(self.parent, self);
            }
        }

        self.onopen = function() {
            // Parent
            if (typeof(self.parent.onopen) === 'function') {
                self.parent.onopen(self.parent, self);
            }
        }

        /**
         * Close the modal
         */
        self.close = function() {
            // Close modals with higher level
            self.parent.close(index);
        }

        /**
         * Open submenu handler
         * @param {object} s
         * @param {boolean} cursor - Activate the first item
         */
        self.open = function(s, cursor) {
            if (s.submenu) {
                // Get the modal in the container of modals
                let item = self.parent.modals[index+1];
                if (! item) {
                    // Modal need to be created
                    item = self.parent.create();
                }
                // Get the parent from this one
                let parent = self.parent.modals[index].modal;
                // Get the self of the modal
                let modal = item.modal;
                // Update modal content
                if (modal.options !== s.submenu) {
                    // Close modals with higher level
                    modal.options = s.submenu;
                    // Close other modals
                    self.parent.close(index+1);
                }
                // Open modal
                modal.closed = false;
                // Update selected modal
                self.parent.modalIndex = index+1;
                // Define the position
                modal.top = parent.top + s.el.offsetTop + 2;
                modal.left = parent.left + 248;

                // Activate the cursor
                if (cursor === true) {
                    // Place cursor in the first position
                    modal.options[0].cursor = true;
                    // Position cursor
                    modal.cursor = 0;
                }

                onopen(modal, s.submenu)
            } else {
                // Close modals with higher level
                self.parent.close(index+1);
            }
        }

        // Mouse open
        self.mouseUp = function(s, e) {
            if (typeof(s.onclick) === 'function') {
                s.onclick.call(s, e, s.el);
            }
            if (! s.submenu) {
                self.close();
            }
        }

        self.mouseEnter = function(s) {
            if (delayTimer) {
                clearTimeout(delayTimer);
            }
            delayTimer = setTimeout(function() {
                self.open(s);
            }, 200);
        }

        self.mouseLeave = function() {
            if (delayTimer) {
                clearTimeout(delayTimer);
            }
        }

        let template = `<Modal position="absolute" :overflow="true" :closed="true" :ref="self.modal" :responsive="false" :auto-adjust="true" :focus="false" :layers="false" :onopen="self.onopen" :onclose="self.onclose">
            <div class="lm-menu-submenu">
                <Item :loop="self.options" />
            </div>
        </Modal>`;

        return lemonade.element(template, self, { Item: Item });
    }

    const setCursor = function(direction) {
        let cursor = null;

        if (typeof(this.cursor) !== 'undefined') {
            if (! direction) {
                // Up
                cursor = this.cursor - 1;
                if (cursor < 0) {
                    cursor = this.options.length - 1;
                }
            } else {
                // Down
                cursor = this.cursor + 1;
                if (cursor >= this.options.length) {
                    cursor = 0;
                }
            }
        }

        // Remove the cursor
        if (cursor === null) {
            if (direction) {
                cursor = 0;
            } else {
                cursor = this.options.length - 1;
            }
        } else {
            this.options[this.cursor].cursor = false;
        }
        // Add the cursor
        this.options[cursor].cursor = true;
        // Cursor
        this.cursor = cursor;
        // If is line move to the next one
        if (this.options[cursor].type === 'line') {
            setCursor.call(this, direction);
        }

        return true;
    }

    /**
     * Reset the cursor for a contextmenu
     */
    const resetCursor = function() {
        // Contextmenu modal
        let item = this.options[this.cursor];
        // Cursor is found so reset it
        if (typeof(item) !== 'undefined') {
            // Remove the cursor style
            item.cursor = false;
            // Delete reference index
            delete this.cursor;
        }
    }

    const actionCursor = function(e) {
        // Contextmenu modal
        let item = this.options[this.cursor];
        // Cursor is found so reset it
        if (typeof(item) !== 'undefined') {
            // Execute action
            if (typeof(item.onclick) === 'function') {
                item.onclick.call(item, e, item.el);
            }
            // Open sub menu in case exists
            if (item.submenu) {
                this.parent.open(item);
                return true;
            }
        }
    }

    /**
     * Open a sub option of the contextmenu by a user action
     * @returns {boolean}
     */
    const openSubmenu = function() {
        // Get the selected cursor
        let item = this.options[this.cursor];
        // Open submenu
        if (typeof(item) !== 'undefined') {
            // Open submenu in case that exists
            if (item.submenu && ! item.disabled) {
                this.parent.open(item, true);
                return true;
            }
        }
    }

    const onopen = function(s, options) {
        // Onopen
        for (let i = 0; i < options.length; i++) {
            if (typeof(options[i].onopen) === 'function') {
                options[i].onopen(s);
            }
        }
    }

    const Contextmenu = function() {
        let self = this;

        // Container for all modals
        self.modals = [];
        self.modalIndex = 0;

        self.create = function() {
            // Create a new self for each modal
            let s = {
                parent: self,
            };
            // Render the modal inside the main container
            lemonade.render(Create, self.el, s);
            // Add the reference of the modal in a container
            self.modals.push(s);
            // Return self
            return s;
        }

        self.open = function(options, x, y, e) {
            // Get the main modal
            let modal = self.modals[0].modal;
            // Reset cursor
            resetCursor.call(modal);

            // Current state
            if (! e || e.type === 'contextmenu') {
                modal.closed = false;
            } else if (e.type === 'click') {
                modal.closed = ! modal.closed;
            }
            // If the modal is open and the content is different from what is shown
            if (modal.closed === false) {
                // Close modals with higher level
                self.close(1);
                // Update the data
                if (modal.options !== options) {
                    // Refresh content
                    modal.options = options;
                }
                // Define new position
                modal.top = y;
                modal.left = x;
                onopen(self, options);
            }
        }
        
        self.close = function(level) {
            // Close all modals from the level specified
            self.modals.forEach(function(value, k) {
                if (k >= level) {
                    // Close the modal
                    value.modal.closed = true;
                }
            });
            // Keep the index of the modal that is opened
            self.modalIndex = level ? level - 1 : 0;
        }

        self.onload = function() {
            if (! self.root) {
                self.root = self.el.parentNode;
            }

            // Keyboard event
            self.root.addEventListener("keydown", function(e) {
                // Modal object
                let m = self.modals[self.modalIndex].modal;
                // Something happens
                let ret = false;
                // Control
                if (e.key === 'ArrowLeft') {
                    if (self.modalIndex > 0) {
                        // Close modal
                        m.parent.close();
                        // Action happened
                        ret = true;
                    }
                } else if (e.key === 'ArrowRight') {
                    ret = openSubmenu.call(m);
                } else if (e.key === 'ArrowUp') {
                    ret = setCursor.call(m, 0);
                } else if (e.key === 'ArrowDown') {
                    ret = setCursor.call(m, 1);
                } else if (e.key === 'Enter') {
                    ret = actionCursor.call(m, e);
                }

                // Something important happen so block any progression
                if (ret === true) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                }
            });

            // Create event for focus out
            self.root.addEventListener("focusout", (e) => {
                if (! self.root.contains(e.relatedTarget)) {
                    self.close(0);
                }
            });

            // Parent
            self.root.addEventListener("contextmenu", function(e) {
                let [x,y] = getCoords(e);
                // Open the context menu
                let scrollPosition = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
                self.open(self.options, x, y+scrollPosition, e);
                e.preventDefault();
                e.stopImmediatePropagation();
            });

            self.root.setAttribute('tabindex', -1);

            // Create first menu
            self.create();
        }

        return `<div class="lm-menu"></div>`;
    }

    lemonade.setComponents({ Contextmenu: Contextmenu });

    lemonade.createWebComponent('contextmenu', Contextmenu);

    return function (root, options) {
        if (typeof (root) === 'object') {
            lemonade.render(Contextmenu, root, options)
            return options;
        } else {
            return Contextmenu.call(this, root)
        }
    }
})));

/***/ }),

/***/ 674:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * Implementar o page up and down
 * botao reset e done
 * traducoes
 */


if (!Modal && "function" === 'function') {
    var Modal = __webpack_require__(211);
}

; (function (global, factory) {
     true ? module.exports = factory() :
    0;
}(this, (function () {

    // Default row height
    let defaultRowHeight = 24;

    /**
     * Compare two arrays to see if contains exact the same elements
     * @param {number|number[]} a1
     * @param {number|number[]} a2
     */
    const compareValues = function (a1, a2) {
        if (!a1 || !a2) {
            return false;
        }
        if (!Array.isArray(a1) || !Array.isArray(a2)) {
            if (a1 === a2) {
                return true;
            } else {
                return false;
            }
        } else {
            let i = a1.length;
            if (i !== a2.length) {
                return false;
            }
            while (i--) {
                if (a1[i] !== a2[i]) {
                    return false;
                }
            }
        }
        return true;
    }

    const lazyLoading = function (self) {
        /**
         * Get the position from top of a row by its index
         * @param item
         * @returns {number}
         */
        const getRowPosition = function (item) {
            // Position from top
            let top = 0;
            if (item) {
                let items = self.rows;
                if (items && items.length) {
                    let index = self.rows.indexOf(item);
                    // Go through the items
                    for (let j = 0; j < index; j++) {
                        top += items[j].height || defaultRowHeight;
                    }
                }
            }
            return top;
        }

        const updateScroll = function () {
            let items = self.rows;
            if (items) {
                // Before control
                let before = true;
                // Total of items in the container
                let numOfItems = items.length;
                // Position from top
                let height = 0;
                // Size of the adjustment
                let size = 0;
                // Go through the items
                for (let j = 0; j < numOfItems; j++) {
                    let h = items[j].height || defaultRowHeight;
                    // Height
                    height += h;
                    // Start tracking all items as before
                    if (items[j] === self.result[0]) {
                        before = false;
                    }
                    // Adjustment
                    if (before) {
                        size += h;
                    }
                }
                // Update height
                scroll.style.height = height + 'px';
                // Adjust scroll position
                return size;
            }
            return false;
        }

        const getVisibleRows = function (reset) {
            let items = self.rows;
            if (items) {
                let adjust;
                // Total of items in the container
                let numOfItems = items.length;
                // Get the position from top
                let y = el.scrollTop;
                // Get the height
                let h = null;
                if (self.type === 'searchbar' || self.type === 'picker') {
                    // Priority should be the size used on the viewport
                    h = y + (el.offsetHeight || self.height);
                } else {
                    // Priority is the height define during initialization
                    h = y + (self.height || el.offsetHeight);
                }
                // Go through the items
                let rows = [];
                // Height
                let height = 0;
                // Go through all items
                for (let j = 0; j < numOfItems; j++) {
                    if (items[j].visible !== false) {
                        // Height
                        let rowHeight = items[j].height || defaultRowHeight;
                        // Return on partial width
                        if (height + rowHeight > y && height < h) {
                            rows.push(items[j]);
                        }
                        height += rowHeight;
                    }
                }

                // Update visible rows
                if (reset || !compareValues(rows, self.result)) {
                    // Render the items
                    self.result = rows;
                    // Adjust scroll height
                    let adjustScroll = reset;
                    // Adjust scrolling
                    for (let i = 0; i < rows.length; i++) {
                        // Item
                        let item = rows[i];
                        // Item height
                        let h = item.el.offsetHeight;
                        // Update row height
                        if (!item.height || h !== item.height) {
                            // Keep item height
                            item.height = h;
                            // Adjust total height
                            adjustScroll = true;
                        }
                    }

                    // Update scroll if the height of one element has been changed
                    if (adjustScroll) {
                        // Adjust the scroll height
                        adjust = updateScroll();
                    }
                }

                // Adjust position of the first element
                let position = getRowPosition(self.result[0]);
                let diff = position - el.scrollTop;
                if (diff > 0) {
                    diff = 0;
                }
                self.container.style.top = diff + 'px';

                return adjust;
            }
        }

        /**
         * Move the position to the top and re-render based on the scroll
         * @param reset
         */
        const render = function (reset) {
            // Move scroll to the top
            el.scrollTop = 0;
            // Reset scroll
            updateScroll();
            // Append first batch
            getVisibleRows(reset);
        }

        /**
         * Will adjust the items based on the scroll position offset
         */
        self.adjustPosition = function (item) {
            if (item.el) {
                let h = item.el.offsetHeight;
                let calc = item.el.offsetTop + h;
                if (calc > el.offsetHeight) {
                    let size = calc - el.offsetHeight;
                    if (size < h) {
                        size = h;
                    }
                    el.scrollTop -= -1 * size;
                }
            }
        }

        // Controls
        const scrollControls = function () {
            getVisibleRows(false);
        }

        // Element for scrolling
        let el = self.container.parentNode;
        el.classList.add('lm-lazy');
        // Div to represent the height of the content
        const scroll = document.createElement('div');
        scroll.classList.add('lm-lazy-scroll');
        // Force the height and add scrolling
        el.appendChild(scroll);
        el.addEventListener('scroll', scrollControls, { passive: true });
        el.addEventListener('wheel', scrollControls, { passive: true });
        self.container.classList.add('lm-lazy-items');

        self.goto = function (item) {
            el.scrollTop = getRowPosition(item);
            let adjust = getVisibleRows(false);
            if (adjust) {
                el.scrollTop = adjust;
                // Last adjust on the visible rows
                getVisibleRows(false);
            }
        }

        return (prop) => {
            if (prop === 'rows') {
                render(true);
            }
        }
    }

    const Dropdown = function (html) {
        let self = this;
        // Internal value controllers
        let value = [];
        // Cursor
        let cursor = null;
        // Control events
        let ignoreEvents = false;
        // Default widht
        if (!self.width) {
            self.width = 260;
        }
        // Lazy loading global instance
        let lazyloading = null;

        // Data
        if (! Array.isArray(self.data)) {
            self.data = [];
        }
        let data = JSON.parse(JSON.stringify(self.data));

        if (html) {
            let select = document.createElement('select');
            select.innerHTML = html.trim();
            for (let i = 0; i < select.children.length; i++) {
                let option = select.children[i];
                if (option.tagName === 'OPTION') {
                    let text = option.textContent;
                    let value = option.getAttribute('value');
                    if (value === null) {
                        value = text;
                    }
                    self.data.push({ text: text, value: value });
                }
            }
        }

        // Custom events defined by the user
        let onload = self.onload;
        let onchange = self.onchange;

        // Cursor controllers
        const setCursor = function (index, force) {
            let item = self.rows[index];

            if (typeof (item) !== 'undefined') {
                // Set cursor number
                cursor = index;
                // Set visual indication
                item.cursor = true;
                // Go to the item on the scroll in case the item is not on the viewport
                if (!(item.el && item.el.parentNode) || force === true) {
                    // Goto method
                    self.goto(item);
                }
                // Adjust cursor position
                setTimeout(function () {
                    self.adjustPosition(item);
                });
            }
        }

        const removeCursor = function (reset) {
            if (cursor !== null) {
                if (typeof (self.rows[cursor]) !== 'undefined') {
                    self.rows[cursor].cursor = false;
                }
                if (reset) {
                    // Cursor is null
                    cursor = null;
                }
            }
        }

        const moveCursor = function (direction, jump) {
            // Remove cursor
            removeCursor();
            // Last item
            let last = self.rows.length - 1;
            if (jump) {
                if (direction < 0) {
                    cursor = 0;
                } else {
                    cursor = last;
                }
            } else {
                // Position
                if (cursor === null) {
                    cursor = 0;
                } else {
                    // Move previous
                    cursor = cursor + direction;
                }
                // Reach the boundaries
                if (direction < 0) {
                    // Back to the last one
                    if (cursor < 0) {
                        cursor = last;
                    }
                } else {
                    // Back to the first one
                    if (cursor > last) {
                        cursor = 0;
                    }
                }
            }
            // Add cursor
            setCursor(cursor);
        }

        const setData = function () {
            // Estimate width
            let width = self.width;
            // Data
            data = JSON.parse(JSON.stringify(self.data));
            // Re-order to make sure groups are in sequence
            if (data && data.length) {
                data.sort((a, b) => {
                    // Compare groups
                    if (a.group && b.group) {
                        return a.group.localeCompare(b.group);
                    }
                    return 0;
                });
                let group = '';
                // Define group headers
                data.map((v) => {
                    // Compare groups
                    if (v && v.group && v.group !== group) {
                        v.header = true;
                        group = v.group;
                    }
                });
                // Width && values
                data.map(function (s) {
                    // Estimated width of the element
                    if (s.text) {
                        width = Math.max(width, s.text.length * 8);
                    }
                });
            }
            // Adjust the width
            let w = self.input.offsetWidth;
            if (width < w) {
                width = w;
            }
            // Estimated with based on the text
            if (self.width < width) {
                self.width = width;
            }
            self.el.style.width = self.width + 'px';
            // Height
            self.height = 400;
            // Animation for mobile
            if (document.documentElement.clientWidth < 800) {
                self.animation = true;
            }
            // Data to be listed
            self.rows = data;
        }

        const updateLabel = function () {
            if (value && value.length) {
                self.input.textContent = value.filter(v => v.selected).map(i => i.text).join('; ');
            } else {
                self.input.textContent = '';
            }
        }

        const setValue = function (v, ignoreEvent) {
            // Values
            let newValue;
            if (!Array.isArray(v)) {
                if (typeof (v) === 'string') {
                    newValue = v.split(';');
                } else {
                    newValue = [v];
                }
            } else {
                newValue = v;
            }

            // Width && values
            value = [];

            if (Array.isArray(data)) {
                data.map(function (s) {
                    // Select values
                    if (newValue.indexOf(s.value) !== -1) {
                        s.selected = true;
                        value.push(s);
                    } else {
                        s.selected = false;
                    }
                });
            }

            // Update label
            updateLabel();

            // Component onchange
            if (! ignoreEvent && typeof(onchange) === 'function') {
                onchange.call(self, self, getValue());
            }
        }

        const getValue = function () {
            if (self.multiple) {
                if (value && value.length) {
                    return value.filter(v => v.selected).map(i => i.value);
                }
                return [];
            } else {
                if (value && value.length) {
                    return value[0].value;
                } else {
                    return '';
                }
            }
        }

        const onclose = function () {
            // Cursor
            removeCursor(true);
            // Reset search
            if (self.autocomplete) {
                // Go to begin of the data
                self.rows = data;
                // Remove editable attribute
                self.input.removeAttribute('contenteditable');
                // Clear input
                self.input.textContent = '';
            }

            // Current value
            let newValue = getValue();

            // If that is different from the component value
            if (!compareValues(newValue, self.value)) {
                self.value = newValue;
            } else {
                // Update label
                updateLabel();
            }

            // Identify the new state of the dropdown
            self.state = false;

            if (typeof (self.onclose) === 'function') {
                self.onclose(self);
            }
        }

        const onopen = function () {
            self.state = true;
            // Value
            let v = value[value.length - 1];
            // Make sure goes back to the top of the scroll
            if (self.container.parentNode.scrollTop > 0) {
                self.container.parentNode.scrollTop = 0;
            }
            // Move to the correct position
            if (v) {
                // Mark the position of the cursor to the same element
                setCursor(self.rows.indexOf(v), true);
            }
            // Prepare search field
            if (self.autocomplete) {
                // Clear input
                self.input.textContent = '';
                // Editable
                self.input.setAttribute('contenteditable', true);
                // Focus on the item
                self.input.focus();
            }

            if (typeof (self.onopen) === 'function') {
                self.onopen(self);
            }
        }

        self.add = async function (e) {
            if (!self.input.textContent) {
                return false;
            }

            e.preventDefault();

            // New item
            let s = {
                text: self.input.textContent,
                value: self.input.textContent,
            }

            // Event
            if (typeof (self.onbeforeinsert) === 'function') {
                let elClass = self.el.classList;
                elClass.add('lm-dropdown-loading');
                let ret = await self.onbeforeinsert(self, s);
                elClass.remove('lm-dropdown-loading');
                if (ret === false) {
                    return;
                } else if (ret) {
                    s = ret;
                }
            }

            // Process the data
            data.push(s);
            // Select the new item
            self.select(e, s);
            // Close dropdown
            self.close();

            // Event
            if (typeof (self.oninsert) === 'function') {
                self.oninsert(self, s);
            }
        }

        self.search = function (e) {
            if (self.state && self.autocomplete) {
                // Filter options
                let temp;
                if (! self.input.textContent) {
                    temp = self.data;
                } else {
                    temp = self.data.filter(item => {
                        return item.selected === true ||
                            (item.text.toLowerCase().includes(self.input.textContent.toLowerCase())) ||
                            (item.group && item.group.toLowerCase().includes(self.input.textContent.toLowerCase()));
                    });
                }
                // Cursor
                removeCursor(true);
                // Update the data from the dropdown
                self.rows = temp;
            }
        }

        self.open = function () {
            if (self.modal && self.modal.closed) {
                // Open the modal
                self.modal.closed = false;
            }
        }

        self.close = function () {
            // Close the modal
            if (self.modal) {
                self.modal.closed = true;
            }
        }

        self.toggle = function () {
            if (self.modal) {
                if (self.modal.closed) {
                    self.open();
                } else {
                    self.close();
                }
            }
        }

        self.click = function (e) {
            if (self.autocomplete) {
                let x;
                if (e.changedTouches && e.changedTouches[0]) {
                    x = e.changedTouches[0].clientX;
                } else {
                    x = e.clientX;
                }
                if (e.target.offsetWidth - (x - e.target.offsetLeft) < 20) {
                    self.toggle();
                } else {
                    self.open();
                }
            } else {
                self.toggle();
            }
        }

        self.select = function (e, s) {
            if (s) {
                if (self.multiple === true) {
                    let position = value.indexOf(s);
                    if (position === -1) {
                        value.push(s);
                        s.selected = true;
                    } else {
                        value.splice(position, 1);
                        s.selected = false;
                    }
                } else {
                    if (value[0] === s) {
                        if (self.allowempty === false) {
                            s.selected = true;
                        } else {
                            s.selected = !s.selected;
                        }
                    } else {
                        if (value[0]) {
                            value[0].selected = false;
                        }
                        s.selected = true;
                    }
                    if (s.selected) {
                        value = [s];
                    } else {
                        value = [];
                    }
                    // Close the modal
                    self.close();
                }
            }
        }

        self.getGroup = function () {
            if (this.group && this.header) {
                return this.group;
            } else {
                return '';
            }
        }

        self.onload = function () {
            if (self.type !== "inline") {
                // Create modal instance
                self.modal = {
                    closed: true,
                    focus: false,
                    width: self.width,
                    onopen: onopen,
                    onclose: onclose,
                    position: 'absolute',
                    'auto-adjust': true,
                    'auto-close': false,
                };
                // Generate modal
                Modal(self.el.children[1], self.modal);
            } else {
                // For inline dropdown
                self.el.setAttribute('tabindex', 0);
                // Remove search
                self.input.remove();
            }

            if (self.url && data.length === 0) {
                const xhr = new XMLHttpRequest();
                
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        if (xhr.status === 200) {
                            data = JSON.parse(xhr.responseText);
                        } else {
                            console.error('Failed to fetch data. Status code: ' + xhr.status);
                        }
                    }
                };
                
                xhr.open('GET', self.url, true);
                xhr.setRequestHeader('Content-Type', 'text/json')
                xhr.send();
            }

            // Loading controls
            lazyloading = lazyLoading(self);
            // Process the data
            setData();
            // Set value
            if (typeof (self.value) !== 'undefined') {
                setValue(self.value, true);
            }
            // Focus out of the component
            self.el.addEventListener('focusout', function (e) {
                if (self.modal) {
                    if (!(e.relatedTarget && self.el.contains(e.relatedTarget)) && !self.el.contains(e.relatedTarget)) {
                        if (!self.modal.closed) {
                            self.modal.closed = true;
                        }
                    }
                }
            });
            // Key events
            self.el.addEventListener('keydown', function (e) {
                if (! self.modal.closed) {
                    let prevent = false;
                    if (e.key === 'ArrowUp') {
                        moveCursor(-1);
                        prevent = true;
                    } else if (e.key === 'ArrowDown') {
                        moveCursor(1);
                        prevent = true;
                    } else if (e.key === 'Home') {
                        moveCursor(-1, true);
                        if (!self.autocomplete) {
                            prevent = true;
                        }
                    } else if (e.key === 'End') {
                        moveCursor(1, true);
                        if (!self.autocomplete) {
                            prevent = true;
                        }
                    } else if (e.key === 'Enter') {
                        self.select(e, self.rows[cursor]);
                        prevent = true;
                    } else if (e.key === 'Escape') {
                        self.modal.closed = true;
                        prevent = true;
                    } else {
                        if (e.keyCode === 32 && !self.autocomplete) {
                            self.select(e, self.rows[cursor]);
                        }
                    }

                    if (prevent) {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }
                } else {
                    if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'Enter') {
                        self.modal.closed = false;
                    }
                }
            });
            // Custom event by the developer
            if (typeof (onload) === 'function') {
                onload(self);
            }
        }

        self.onchange = function (prop) {
            if (prop === 'value') {
                setValue(self.value);
            } else if (prop === 'data') {
                setData();
                self.value = null;
            }

            if (typeof (lazyloading) === 'function') {
                lazyloading(prop);
            }
        }

        /**
         * Sanitize any HTML from be paste on the search
         * @param e
         */
        self.onpaste = function (e) {
            let text;
            if (e.clipboardData || e.originalEvent.clipboardData) {
                text = (e.originalEvent || e).clipboardData.getData('text/plain');
            } else if (window.clipboardData) {
                text = window.clipboardData.getData('Text');
            }
            text = text.replace(/(\r\n|\n|\r)/gm, "");
            document.execCommand('insertText', false, text)
            e.preventDefault();
        }

        return `<div class="lm-dropdown" data-insert="{{self.insert}}" data-type="{{self.type}}" data-state="{{self.state}}" :value="self.value" :data="self.data">
            <div class="lm-dropdown-header">
                <div class="lm-dropdown-input" onpaste="self.onpaste" oninput="self.search" onmousedown="self.click" placeholder="{{self.placeholder}}" :ref="self.input" tabindex="0"></div>
                <div class="lm-dropdown-add" onmousedown="self.add"></div>
                <div class="lm-dropdown-header-controls">
                    <button onclick="self.close" class="lm-dropdown-done">Done</button>
                </div>
            </div>
            <div class="lm-dropdown-content">
                <div>
                    <div :loop="self.result" :ref="self.container" :rows="self.rows">
                        <div class="lm-dropdown-item" onclick="self.parent.select" data-cursor="{{self.cursor}}" data-selected="{{self.selected}}" data-group="{{self.parent.getGroup}}">
                            <div><img :src="self.image" /><span>{{self.text}}</span></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>`;
    }

    lemonade.setComponents({ Dropdown: Dropdown });

    lemonade.createWebComponent('dropdown', Dropdown);

    return function (root, options) {
        if (typeof (root) === 'object') {
            lemonade.render(Dropdown, root, options)
            return options;
        } else {
            return Dropdown.call(this, root)
        }
    }
})));

/***/ }),

/***/ 211:
/***/ (function(module) {

/**
 * pin the modal to the left panel
 */


;(function (global, factory) {
     true ? module.exports = factory() :
    0;
}(this, (function () {

    // References
    const modals = [];
    // State of the resize and move modal
    let state = {};
    // Internal controls of the action of resize and move
    let controls = {};
    // Width of the border
    let cornerSize = 10;
    // Container with minimized modals
    const minimizedModals = [];
    // Default z-index for the modals
    const defaultZIndex = 20;

    /**
     * Send the modal to the front
     * @param container
     */
    const sendToFront = function(container) {
        let highestXIndex = defaultZIndex;
        for (let i = 0; i < modals.length; i++) {
            const zIndex = parseInt(modals[i].el.style.zIndex);
            if (zIndex > highestXIndex) {
                highestXIndex = zIndex;
            }
        }
        container.style.zIndex = highestXIndex + 1;
    }

    /**
     * Send modal to the back
     * @param container
     */
    const sendToBack = function(container) {
        container.style.zIndex = defaultZIndex;
    }

    // Get the coordinates of the action
    const getCoords = function(e) {
        let x;
        let y;

        if (e.changedTouches && e.changedTouches[0]) {
            x = e.changedTouches[0].clientX;
            y = e.changedTouches[0].clientY;
        } else {
            x = e.clientX;
            y = e.clientY;
        }

        return [x,y];
    }

    // Get the button status
    const getButton = function(e) {
        e = e || window.event;
        if (e.buttons) {
            return e.buttons;
        } else if (e.button) {
            return e.button;
        } else {
            return e.which;
        }
    }

    // Finalize any potential action
    const mouseUp = function(e) {
        // Finalize all actions
        if (typeof(controls.action) === 'function') {
            controls.action();
        }
        setTimeout(function() {
            // Remove cursor
            if (controls.e) {
                controls.e.style.cursor = '';
            }
            // Reset controls
            controls = {};
            // Reset state controls
            state = {
                x: null,
                y: null,
            }
        }, 0)
    }

    const mouseMove = function(e) {
        if (! getButton(e)) {
            return false;
        }
        // Get mouse coordinates
        let [x,y] = getCoords(e);

        // Move modal
        if (controls.type === 'move') {
            if (state && state.x == null && state.y == null) {
                state.x = x;
                state.y = y;
            }

            let dx = x - state.x;
            let dy = y - state.y;
            let top = controls.e.offsetTop + dy;
            let left = controls.e.offsetLeft + dx;

            // Update position
            controls.top = top;
            controls.left = left;
            controls.e.style.top = top + 'px';
            controls.e.style.left = left + 'px';

            state.x = x;
            state.y = y;
            state.top = top;
            state.left = left;
        } else if (controls.type === 'resize') {
            let top = null;
            let left = null;
            let width = null;
            let height = null;

            if (controls.d === 'e-resize' || controls.d === 'ne-resize' || controls.d === 'se-resize') {
                width = controls.w + (x - controls.x);

                if (e.shiftKey) {
                    height = controls.h + (x - controls.x) * (controls.h / controls.w);
                }
            } else if (controls.d === 'w-resize' || controls.d === 'nw-resize'|| controls.d === 'sw-resize') {
                left = controls.l + (x - controls.x);
                // Do not move further
                if (left >= controls.l) {
                    left = controls.l;
                }
                // Update width
                width = controls.l + controls.w - left;
                // Consider shift to update height
                if (e.shiftKey) {
                    height = controls.h - (x - controls.x) * (controls.h / controls.w);
                }
            }

            if (controls.d === 's-resize' || controls.d === 'se-resize' || controls.d === 'sw-resize') {
                if (! height) {
                    height = controls.h + (y - controls.y);
                }
            } else if (controls.d === 'n-resize' || controls.d === 'ne-resize' || controls.d === 'nw-resize') {
                top = controls.t + (y - controls.y);
                // Do not move further
                if (top >= controls.t) {
                    top = controls.t;
                }
                // Update height
                height = controls.t + controls.h - top;
            }

            if (top) {
                controls.e.style.top = top + 'px';
            }
            if (left) {
                controls.e.style.left = left + 'px';
            }
            if (width) {
                controls.e.style.width = width + 'px';
            }
            if (height) {
                controls.e.style.height = height + 'px';
            }
        }
    }

    document.addEventListener('mouseup', mouseUp);
    document.addEventListener('mousemove', mouseMove);

    const isTrue = function(e) {
        return e === true || e === 1 || e === 'true';
    }

    // Dispatcher
    const Dispatch = function(type){
        if (typeof this[type] === 'function') {
            let args = Array.from(arguments);
            args.shift();
            this[type](...args)
        }
    }

    const refreshMinimized = function() {
        let items = minimizedModals;
        let numOfItems = items.length;
        let width = 10;
        let height = 55;
        let offsetWidth = window.innerWidth;
        let offsetHeight = window.innerHeight;
        for (let i = 0; i < numOfItems; i++) {
            let item = items[i];
            item.el.style.left = width + 'px';
            item.el.style.top = offsetHeight - height + 'px';
            width += 205;

            if (offsetWidth - width < 205) {
                width = 10;
                height += 50;
            }
        }
    }

    const delayAction = function(self, action) {
        // Make sure to remove the transformation before minimize to preserve the animation
        if (self.el.style.marginLeft || self.el.style.marginTop) {
            // Make sure no animation during this process
            self.el.classList.add('action');
            // Remove adjustment
            removeMargin(self);
            // Make sure to continue with minimize
            setTimeout(function() {
                // Remove class
                self.el.classList.remove('action');
                // Call action
                action(self);
            },0)

            return true;
        }
    }

    const setMini = function(self) {
        if (delayAction(self, setMini)) {
            return;
        }

        // Minimize modals
        minimizedModals.push(self);

        self.el.top = self.el.offsetTop;
        self.el.left = self.el.offsetLeft;

        if (! self.el.style.top) {
            self.el.style.top = self.el.top + 'px';
        }
        if (! self.el.style.left) {
            self.el.style.left = self.el.left + 'px';
        }

        self.el.translateY = 0;
        self.el.translateX = 0;

        // Refresh positions
        setTimeout(function() {
            refreshMinimized();
            self.minimized = true;
        },10)
    }

    const removeMini = function(self) {
        minimizedModals.splice(minimizedModals.indexOf(self), 1);
        self.minimized = false;
        self.el.style.top = self.el.top + 'px';
        self.el.style.left = self.el.left + 'px';
        // Refresh positions
        setTimeout(() => {
            refreshMinimized();
        }, 10);
        // Refresh positions
        setTimeout(() => {
            if (self.top === '') {
                self.el.style.top = '';
            }
            if (self.left === '') {
                self.el.style.left = '';
            }
        }, 400);
    }

    const removeMargin = function(self) {
        if (self.el.style.marginLeft) {
            let y = self.el.offsetLeft;
            self.el.style.marginLeft = '';
            self.left = y;
        }

        if (self.el.style.marginTop) {
            let x = self.el.offsetTop;
            self.el.style.marginTop = '';
            self.top = x;
        }
    }

    const adjustHorizontal = function(self) {
        if (! isTrue(self['auto-adjust'])) {
            return false;
        }

        self.el.style.marginLeft = '';
        let viewportWidth = window.innerWidth;
        let margin = 10;

        if (self.position) {
            if (self.position === 'absolute') {
                let w = document.documentElement.offsetWidth;
                if (w > viewportWidth) {
                    //viewportWidth = w;
                }
            } else if (self.position !== 'center') {
                margin = 0;
            }
        }

        let el = self.el.getBoundingClientRect();

        let rightEdgeDistance = viewportWidth - (el.left + el.width);
        let transformX = 0;

        if (self.position === 'absolute') {
            if (rightEdgeDistance < 0) {
                transformX = rightEdgeDistance - margin - 10; // 10 is the scroll width
            }
        } else {
            if (rightEdgeDistance < 0) {
                transformX = rightEdgeDistance - margin;
            }
        }

        if (el.left < 0) {
            transformX = margin - el.left;
        }
        if (transformX !== 0) {
            self.el.style.marginLeft = transformX + 'px';
        }
    }

    const adjustVertical = function(self) {
        if (! isTrue(self['auto-adjust'])) {
            return false;
        }

        self.el.style.marginTop = '';
        let viewportHeight = window.innerHeight;
        let margin = 10;

        if (self.position) {
            if (self.position === 'absolute') {
                let h = document.documentElement.offsetHeight;
                if (h > viewportHeight) {
                    //viewportHeight = h;
                }
            } else if (self.position !== 'center') {
                margin = 0;
            }
        }

        let el = self.el.getBoundingClientRect();

        let bottomEdgeDistance = viewportHeight - (el.top + el.height);
        let transformY = 0;

        if (self.position === 'absolute') {
            if (bottomEdgeDistance < 5) {
                transformY = (-1 * el.height) - margin - 20;
            }
        } else {
            if (bottomEdgeDistance < 0) {
                transformY = bottomEdgeDistance - margin;
            }
        }

        if (el.top < 0) {
            transformY = margin - el.top;
        }
        if (transformY !== 0) {
            self.el.style.marginTop = transformY + 'px';
        }
    }

    const removeElements = function(root) {
        // Keep the DOM elements
        let elements = [];
        if (root) {
            while (root.firstChild) {
                elements.push(root.firstChild);
                root.firstChild.remove();
            }
        }
        return elements;
    }

    const appendElements = function(root, elements) {
        if (elements && elements.length) {
            while (elements[0]) {
                root.appendChild(elements.shift());
            }
        }
    }

    const Modal = function (template) {
        let self = this;
        let backdrop = null;
        let elements = null;

        if (this.tagName) {
            // Remove elements from the DOM
            elements = removeElements(this);

            this.addEventListener('dragstart', (e) => {
                e.preventDefault();
            });
        }

        // Make sure keep the state as boolean
        self.closed = !!self.closed;

        // Keep all modals references
        modals.push(self);

        self.back = function() {
            sendToBack(self.el);
        }
        self.front = function() {
            sendToFront(self.el);
        }

        // Onload method
        let onload = self.onload;

        // Native lemonade
        self.onload = function() {
            if (self.url) {
                fetch(self.url)
                    .then(response => response.clone().body)
                    .then(body => {
                        let reader = body.getReader();
                        reader.read().then(function pump({done, value}) {
                            const decoder = new TextDecoder();
                            template += decoder.decode(value.buffer);
                        });
                    });
            }

            // Dimensions
            if (self.width) {
                self.el.style.width = self.width + 'px';
            }
            if (self.height) {
                self.el.style.height = self.height + 'px';
            }
            // Position
            if (self.top) {
                self.el.style.top = self.top + 'px';
            }
            if (self.left) {
                self.el.style.left = self.left + 'px';
            }

            if (self.position === 'absolute' || self.position === 'right' || self.position === 'bottom' || self.position === 'left') {

            } else {
                if (!self.width && self.el.offsetWidth) {
                    self.width = self.el.offsetWidth;
                }
                if (!self.height && self.el.offsetHeight) {
                    self.height = self.el.offsetHeight;
                }

                // Initial centralize
                if (self.position === 'center' || !self.top) {
                    self.top = (window.innerHeight - self.height) / 2;
                }
                if (self.position === 'center' || !self.left) {
                    self.left = (window.innerWidth - self.width) / 2;
                }

                // Responsive
                if (document.documentElement.clientWidth < 800) {
                        // Full screen
                    if (self.height > 300) {
                        self.el.classList.add('fullscreen');
                    }
                }
            }

            // Auto adjust
            adjustHorizontal(self);
            adjustVertical(self);

            // Backdrop
            if (self.backdrop === true) {
                backdrop = document.createElement('div');
                backdrop.classList.add('lm-modal-backdrop');
                backdrop.addEventListener('click', function() {
                    self.closed = true;
                });

                if (self.closed === false) {
                    self.el.parentNode.insertBefore(backdrop, self.el);
                }
            }

            // Bring to front on focus
            if (self.layers !== false) {
                self.el.classList.add('lm-modal-layers');
            }

            // Import content from DOM
            if (self.content) {
                self.el.children[1].appendChild(self.content);
            }

            // Focus out of the component
            self.el.addEventListener('focusout', function(e) {
                if (isTrue(self['auto-close'])) {
                    if (! self.el.contains(e.relatedTarget)) {
                        self.closed = true;
                    }
                }
            });

            // Close and stop propagation
            self.el.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (self.closed === false) {
                        self.closed = true;
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }
                } else if (e.key === 'Enter') {
                    self.click(e);
                }
            });

            // Append elements to the container
            appendElements(self.el.children[1], elements);

            if (typeof(onload) === 'function') {
                Dispatch.call(self, 'onload', self);
            }
        }

        let ignoreEvents = false;

        self.onchange = function(property) {
            if (ignoreEvents) {
                return false;
            }

            if (property === 'closed') {
                if (self.closed === false) {
                    // Focus on the modal
                    if (self.focus !== false) {
                        self.el.focus();
                    }
                    // Show backdrop
                    if (backdrop) {
                        self.el.parentNode.insertBefore(backdrop, self.el);
                    }

                    // Auto adjust
                    adjustHorizontal(self);
                    adjustVertical(self);
                } else {
                    // Hide backdrop
                    if (backdrop) {
                        backdrop.remove();
                    }
                }

                // Call the vents
                self.closed ? Dispatch.call(self,'onclose',self) : Dispatch.call(self,'onopen',self);
            } else if (property === 'top' || property === 'left' || property === 'width' || property === 'height') {
                if (self[property] !== '') {
                    self.el.style[property] = self[property] + 'px';
                } else {
                    self.el.style[property] = '';
                }

                if (property === 'top') {
                    adjustVertical(self);
                }
                if (property === 'left') {
                    adjustHorizontal(self);
                }
            } else if (property === 'position') {
                if (self.position) {
                    if (self.position === 'center') {
                        self.top = (window.innerHeight - self.el.offsetHeight) / 2;
                        self.left = (window.innerWidth - self.el.offsetWidth) / 2;
                    } else {
                        self.top = '';
                        self.left = '';
                    }
                } else {
                    if (! self.top) {
                        self.top = (window.innerHeight - self.el.offsetHeight) / 2;
                    }
                    if (! self.left) {
                        self.left = (window.innerWidth - self.el.offsetWidth) / 2;
                    }
                }
            }
        }
        
        self.mousemove = function(e) {
            if (getButton(e)) {
                return;
            }

            // Get mouse coordinates
            let [x,y] = getCoords(e);
            // Root element of the component
            let item = self.el;
            // Get the position and dimensions
            let rect = item.getBoundingClientRect();

            controls.type = null;
            controls.d = null;
            controls.e = item;
            controls.w = rect.width;
            controls.h = rect.height;
            controls.t = rect.top;
            controls.l = rect.left;

            // When resizable
            if (self.resizable === true) {
                if (e.clientY - rect.top < cornerSize) {
                    if (rect.width - (e.clientX - rect.left) < cornerSize) {
                        item.style.cursor = 'ne-resize';
                    } else if (e.clientX - rect.left < cornerSize) {
                        item.style.cursor = 'nw-resize';
                    } else {
                        item.style.cursor = 'n-resize';
                    }
                } else if (rect.height - (e.clientY - rect.top) < cornerSize) {
                    if (rect.width - (e.clientX - rect.left) < cornerSize) {
                        item.style.cursor = 'se-resize';
                    } else if (e.clientX - rect.left < cornerSize) {
                        item.style.cursor = 'sw-resize';
                    } else {
                        item.style.cursor = 's-resize';
                    }
                } else if (rect.width - (e.clientX - rect.left) < cornerSize) {
                    item.style.cursor = 'e-resize';
                } else if (e.clientX - rect.left < cornerSize) {
                    item.style.cursor = 'w-resize';
                } else {
                    item.style.cursor = '';
                }

                if (item.style.cursor) {
                    controls.type = 'resize';
                    controls.d = item.style.cursor;
                } else {
                    controls.type = null;
                    controls.d = null;
                }
            }

            if (controls.type == null && isTrue(self.draggable)) {
                if (y - rect.top < 40) {
                    item.style.cursor = 'move';
                } else {
                    item.style.cursor = '';
                }

                if (item.style.cursor) {
                    controls.type = 'move';
                    controls.d = item.style.cursor;
                } else {
                    controls.type = null;
                    controls.d = null;
                }
            }
        }

        self.mousedown = function(e) {
            if (! self.minimized) {
                // Get mouse coordinates
                let [x,y] = getCoords(e);
                controls.x = x;
                controls.y = y;
                // Root element of the component
                let item = self.el;
                // Get the position and dimensions
                let rect = item.getBoundingClientRect();
                controls.e = item;
                controls.w = rect.width;
                controls.h = rect.height;
                controls.t = rect.top;
                controls.l = rect.left;
                // If is not minimized
                if (controls.type === 'resize') {
                    // Make sure the width and height is defined for the modal
                    if (! item.style.width) {
                        item.style.width = controls.w + 'px';
                    }
                    if (! item.style.height) {
                        item.style.height = controls.h + 'px';
                    }
                    // This will be the callback when finalize the resize
                    controls.action = function () {
                        self.width = parseInt(item.style.width);
                        self.height = parseInt(item.style.height);
                        controls.e.classList.remove('action');
                        // Event
                        Dispatch.call(self, 'onresize', self, self.width, self.height);
                    }
                    controls.e.classList.add('action');
                } else if (isTrue(self.draggable) && y - rect.top < 40) {
                    // Callback
                    controls.action = function () {
                        self.top = parseInt(item.style.top);
                        self.left = parseInt(item.style.left);
                        controls.e.classList.remove('action');
                        // Event
                        Dispatch.call(self, 'onmove', self, self.top, self.left);
                    }
                    controls.e.classList.add('action');
                    // Remove transform
                    removeMargin(self);
                }
            }
        }

        self.click = function(e) {
            if (e.target.classList.contains('lm-modal-close')) {
                self.closed = true;
            }

            if (e.target.classList.contains('lm-modal-minimize')) {
                // Handles minimized modal positioning
                if (self.minimized === true) {
                    removeMini(self);
                } else {
                    setMini(self);
                }
            }
        }

        self.open = function() {
            if (self.closed === true) {
                self.closed = false;
            }
        }

        self.close = function() {
            if (self.closed === false) {
                self.closed = true;
            }
        }

        if (! template) {
            template = '';
        }

        return `<div class="lm-modal" animation="{{self.animation}}" position="{{self.position}}" closed="{{self.closed}}" closable="{{self.closable}}" minimizable="{{self.minimizable}}" minimized="{{self.minimized}}" overflow="{{self.overflow}}" :top="self.top" :left="self.left" :width="self.width" :height="self.height" onmousedown="self.mousedown" onmousemove="self.mousemove" onclick="self.click" tabindex="-1" role="modal">
            <div class="lm-modal-title" data-title="{{self.title}}" data-icon="{{self.icon}}"><div class="lm-modal-icon">{{self.icon}}</div><div>{{self.title}}</div><div class="lm-modal-icon lm-modal-minimize" tabindex="0"></div><div class="lm-modal-icon lm-modal-close" tabindex="0"></div></div>
            <div>${template}</div>
        </div>`
    }

    const Component = function (root, options, template) {
        if (typeof(root) === 'object') {
            // Remove elements from the DOM
            let elements = removeElements(root);
            // Create the modal
            let e = lemonade.render(Modal, root, options, template);
            // Add elements to the container
            appendElements(e.children[1], elements);

            return options;
        } else {
            return Modal.call(this);
        }
    }

    // Create LemonadeJS Component
    lemonade.setComponents({ Modal: Modal });
    // Create Web Component
    lemonade.createWebComponent('modal', Modal)

    return Component;
})));

/***/ }),

/***/ 238:
/***/ (function(module) {



;(function (global, factory) {
     true ? module.exports = factory() :
    0;
}(this, (function () {

    const Rating = function() {
        let self = this;

        if (! self.number) {
            self.number = 5;
        }
        self.stars = [];

        // Event
        let change = self.onchange;

        // Current self star
        let current = null;

        /**
         * Update the number of stars
         */
        const len = function() {
            // Remove stars
            if (self.number < self.stars.length) {
                self.stars.splice(self.number, self.stars.length);
                if (self.value > self.number) {
                    self.value = self.number;
                }
            }
            // Add missing stars
            for (let i = 0; i < self.number; i++) {
                if (! self.stars[i]) {
                    self.stars[i] = {
                        icon: 'star_outline',
                    };
                }
            }
            // Refresh
            self.refresh('stars');
        }

        const val = function() {
            // Update value
            if (self.value > 0) {
                let t = self.stars[self.value-1];
                if (t) {
                    self.click(null, t);
                }
            }
        }

        self.onchange = function(prop) {
            if (prop === 'number') {
                len();
            } else if (prop === 'value') {
                val();
            }
        }

        self.onload = function() {
            // Bind global method to be compatible with LemonadeJS forms
            self.el.val = function(v) {
                if (typeof(v) === 'undefined') {
                    return self.value;
                } else {
                    self.value = v;
                }
            }

            len();
            val();
        }

        self.click = function(e, s) {
            if (! s.selected) {
                current = null;
            }
            let index = self.stars.indexOf(s);
            for (let i = 0; i < self.number; i++) {
                let selected = i <= index && s !== current ? 1 : 0;
                self.stars[i].selected = selected;
                self.stars[i].el.style.color = selected ? 'red' : '';
                self.stars[i].icon = selected ? 'star' : 'star_outline';
            }
            current = s;

            if (typeof(change) === 'function') {
                change(index+1, s);
            }
        }

        return `<div value="{{self.value}}" number="{{self.number}}" name="{{self.name}}" :loop="self.stars" :ref="self.component" style="cursor: pointer">
            <i class="material-icons" onclick="self.parent.click">{{self.icon}}</i>
        </div>`;
    }

    // Register the LemonadeJS Component
    lemonade.setComponents({ Rating: Rating });
    // Register the web component
    lemonade.createWebComponent('rating', Rating);

    return function (root, options) {
        if (typeof (root) === 'object') {
            lemonade.render(Rating, root, options)
            return options;
        } else {
            return Rating.call(this, root)
        }
    }

})));

/***/ }),

/***/ 203:
/***/ (function(module) {



; (function (global, factory) {
     true ? module.exports = factory() :
    0;
}(this, (function () {

    const Switch = function () {
        let self = this;

        const onchange = self.onchange;

        self.onchange = function(prop, elements, s, oldValue, newValue) {
            if (oldValue !== newValue && typeof(onchange) === 'function') {
                onchange.call(self, self, self.value);
            }
        }

        self.onload = function() {
            if (self.width) {
                self.el.style.width = self.width;
            }
        }

        return `<label class="lm-switch" position="{{self.position}}">
            <input type="checkbox" name="{{self.name}}" disabled="{{self.disabled}}" :bind="self.value" /> <span>{{self.text}}</span>
        </label>`
    }

    // Create LemonadeJS references
    lemonade.setComponents({ Switch: Switch });
    // Create web-component
    lemonade.createWebComponent('switch', Switch);

    return function (root, options) {
        if (typeof (root) === 'object') {
            lemonade.render(Switch, root, options)
            return options;
        } else {
            return Switch.call(this, root);
        }
    }

})));

/***/ }),

/***/ 128:
/***/ (function(module) {



; (function (global, factory) {
     true ? module.exports = factory() :
    0;
}(this, (function () {

    // Dispatcher
    const Dispatch = function(type){
        if (typeof this[type] === 'function') {
            let args = Array.from(arguments);
            args.shift();
            this[type](...args)
        }
    }

    const Tabs = function (html) {
        let self = this
        let elements = [];

        if (this.tagName) {
            // Remove elements from the DOM
            elements = removeElements(this);
        }

        if (self.data) {
            for (let i = 0; i < self.data.length; i++) {
                let d = document.createElement('div');
                d.title = self.data[i].title;
                d.innerHTML = self.data[i].content;
                elements.push(d);
            }
        }

        if (! html) {
            html = '';
        }

        self.tabs = [];

        const select = function (index) {
            index = parseInt(index);

            // Do not select tabs that does not exist
            if (index >= 0 && index < self.tabs.length) {
                for (let i = 0; i < self.content.children.length; i++) {
                    self.headers.children[i].classList.remove('selected');
                    self.content.children[i].classList.remove('selected');
                }
                self.headers.children[index].classList.add('selected');
                self.content.children[index].classList.add('selected');
            }
        }

        self.onload = function () {
            // Append elements to the container
            appendElements(self.el.children[1], elements);

            for (let i = 0; i < self.content.children.length; i++) {
                self.tabs.push({ title: self.content.children[i].title });
            }
            self.refresh('tabs');

            let index = 0;
            if (! isNaN(parseInt(self.selected))) {
                index = parseInt(self.selected);
            }
            select(index);
        }


        self.onchange = function (property) {
            if (property === 'selected') {
                select(self.selected);

                Dispatch.call(self, 'onopen', self, self.selected);
            }
        }

        self.keydown = function(e) {
            if (e.key === 'Enter') {
                self.click(e);
            }
        }

        self.click = function (e) {
            if (e.target.tagName === 'LI') {
                // Avoid select something already selected
                let index = Array.prototype.indexOf.call(e.target.parentNode.children, e.target);
                if (index !== self.selected) {
                    self.selected = index;
                }
            }
        }

        return `<div class="lm-tabs" data-position="{{self.position}}" data-round="{{self.round}}">
            <ul :ref="self.headers" :loop="self.tabs" :selected="self.selected" onclick="self.click" onkeydown="self.keydown" role="tabs"><li class="lm-tab-list-item" tabindex="0" role="tab">{{self.title}}</li></ul>
            <div :ref="self.content" class="lm-tabs-content">${html}</div>
        </div>`
    }

    const removeElements = function(root) {
        // Keep the DOM elements
        let elements = [];
        if (root) {
            while (root.firstChild) {
                elements.push(root.firstChild);
                root.firstChild.remove();
            }
        }
        return elements;
    }

    const appendElements = function(root, elements) {
        if (elements && elements.length) {
            while (elements[0]) {
                root.appendChild(elements.shift());
            }
        }
    }

    const Component = function (root, options) {
        if (typeof (root) === 'object') {
            // Remove elements from the DOM
            let elements = removeElements(root);
            // Create the modal
            let e = lemonade.render(Tabs, root, options);
            // Add elements to the container
            appendElements(e.children[1], elements);

            return options;
        } else {
            return Tabs.call(this);
        }
    }

    lemonade.setComponents({ Tabs: Tabs });

    lemonade.createWebComponent('tabs', Tabs);

    return Component;
})));

/***/ }),

/***/ 796:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



if (!Contextmenu && "function" === 'function') {
    var Contextmenu = __webpack_require__(577);
}

; (function (global, factory) {
     true ? module.exports = factory() :
    0;
}(this, (function () {

    const Topmenu = function() {
        let self = this;
        // Current selection
        let index = null;

        self.open = function(e,s) {
            if (s.submenu) {
                // Keep the selected position
                index = self.options.indexOf(s);
                // Element
                let d = s.el;
                // Focus on the item
                d.focus();
                let x = d.offsetLeft;
                let y = d.offsetTop + d.offsetHeight + 2;
                if (! s.disabled) {
                    self.menu.open(s.submenu, x, y, e);
                }
                // Cancel event
                if (e) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                }
            }
        }

        self.select = function(e,s) {
            if (! self.menu.modals[0].modal.closed) {
                self.open(e,s)
            }
        }

        // Keyboard event
        self.onload = function() {
            self.el.addEventListener("keydown", function(e) {
                // Select top menu
                let select = null;

                if (e.key === 'Enter') {
                    let active = document.activeElement;
                    select = Array.prototype.indexOf.call(active.parentNode.children, active);
                } else {
                    // The contextmenu is opened and the selected level is the first one
                    if (! self.menu.modals[0].modal.closed) {
                        let o = self.options;
                        if (e.key === 'ArrowLeft') {
                            select = index - 1;
                            if (select < 0) {
                                select = o.length - 1;
                            }
                        } else if (e.key === 'ArrowRight') {
                            select = index + 1;
                            if (select >= o.length) {
                                select = 0;
                            }
                        }
                    }
                }

                if (select !== null) {
                    self.open(e,self.options[select]);
                }
            });
        }

        self.cancel = function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
        }

        return `<div class="lm-topmenu" oncontextmenu="self.cancel">
            <div class="lm-topmenu-options" :loop="self.options">
                <div class="lm-topmenu-title" data-disabled="{{self.disabled}}" tabindex="0" oncontextmenu="self.parent.open" onclick="self.parent.open" onmouseover="self.parent.select">{{self.title}}</div>
            </div>
            <Contextmenu :ref="self.menu" />
        </div>`
    }

    lemonade.setComponents({ Topmenu: Topmenu });

    // Register the web component
    lemonade.createWebComponent('topmenu', Topmenu);

    return function (root, options) {
        if (typeof (root) === 'object') {
            lemonade.render(Topmenu, root, options)
            return options;
        } else {
            return Topmenu.call(this, root)
        }
    }
})));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/* harmony import */ var _plugins_calendar_dist_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(533);
/* harmony import */ var _plugins_calendar_dist_index__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_plugins_calendar_dist_index__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _plugins_color_dist_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(444);
/* harmony import */ var _plugins_color_dist_index__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_plugins_color_dist_index__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _plugins_contextmenu_dist_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(577);
/* harmony import */ var _plugins_contextmenu_dist_index__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_plugins_contextmenu_dist_index__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _plugins_dropdown_dist_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(674);
/* harmony import */ var _plugins_dropdown_dist_index__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_plugins_dropdown_dist_index__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _plugins_modal_dist_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(211);
/* harmony import */ var _plugins_modal_dist_index__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_plugins_modal_dist_index__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _plugins_switch_dist_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(203);
/* harmony import */ var _plugins_switch_dist_index__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_plugins_switch_dist_index__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _plugins_tabs_dist_index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(128);
/* harmony import */ var _plugins_tabs_dist_index__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_plugins_tabs_dist_index__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _plugins_topmenu_dist_index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(796);
/* harmony import */ var _plugins_topmenu_dist_index__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_plugins_topmenu_dist_index__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _plugins_rating_dist_index__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(238);
/* harmony import */ var _plugins_rating_dist_index__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_plugins_rating_dist_index__WEBPACK_IMPORTED_MODULE_8__);




















let about = function() {
    return {
        name: 'Lemonade Studio',
        version: '1.4.10',
    }
}

let studio = {
    Calendar: (_plugins_calendar_dist_index__WEBPACK_IMPORTED_MODULE_0___default()),
    Color: (_plugins_color_dist_index__WEBPACK_IMPORTED_MODULE_1___default()),
    Contextmenu: (_plugins_contextmenu_dist_index__WEBPACK_IMPORTED_MODULE_2___default()),
    Dropdown: (_plugins_dropdown_dist_index__WEBPACK_IMPORTED_MODULE_3___default()),
    Modal: (_plugins_modal_dist_index__WEBPACK_IMPORTED_MODULE_4___default()),
    Switch: (_plugins_switch_dist_index__WEBPACK_IMPORTED_MODULE_5___default()),
    Tabs: (_plugins_tabs_dist_index__WEBPACK_IMPORTED_MODULE_6___default()),
    Topmenu: (_plugins_topmenu_dist_index__WEBPACK_IMPORTED_MODULE_7___default()),
    Rating: (_plugins_rating_dist_index__WEBPACK_IMPORTED_MODULE_8___default()),
    about: about,
}

/* harmony default export */ __webpack_exports__["default"] = (studio);
}();
studio = __webpack_exports__["default"];
/******/ })()
;

    return studio;
})));